# 设计模式（c++实现）

------



## 设计模式原则

### 单一职责原则

> 就一个类而言，应该仅有一个引起它变化的原因

- 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏

- 软件设计真正要做的许多内容，就是发现职责并把哪些职责相互分离

- 判断一个是否应该分离出类来：如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个职责

### 开放封闭原则（核心原则）

> 对于软件实体（类、模块、函数等）的扩展是开放的，对于软件实体的更改是封闭的

- 面对需求，对程序的改动那个是通过增加新代码进行的，而不是更改现有的代码。

- 开发人员应该仅对程序中呈现出频繁变化的哪些部分作出抽象，然而，对于应用程序中的每一个部分都刻意进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要！

### 倒转依赖原则（贯穿所有模式）

> 高层模块不应该依赖于底层模块，两个都应该依赖于抽象
>
> 抽象不应该依赖细节，细节应该依赖抽象

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8xlp77hkxj30ms0doq3f.jpg)

说白了就是要针对接口编程，不要对实现编程



### 里式替换原则

> 子类必须能够替换他们的基类（is-a）

只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。



### 接口隔离原则（ISP）

> 不应该强迫客户程序依赖他们不用的方法
>
> 接口应该小而完备



### 优先使用对象组合，而不是类继承

> 继承在某种程度上破坏了封装性，子类父类耦合度高
>
> 对象组合则只要求被组合的对象具有良好定义的接口，耦合度低



### 封装变化点

> 使用封装来创建对象的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合



### 针对接口编程，而不是针对实现编程

> 不将变量类型声明为某个特定的类，而是声明为某个接口
>
> 客户程序不需知道对象具体类型，只需要知道对象的接口
>
> 减少系统中各部分的依赖关系



### 迪米特法则

> 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中那个一个类需要调用另一个类的某个方法的话，可以通过第三者转发这个调用。

也就是在类的结构设计上，每个类都应该尽量降低成员的访问权限，其根本就是强调了类之间的松耦合。





### 原则版本2（SOLID）

SOLID原则是为了写出可复用、可扩展、高内聚、低耦合的代码。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g93emyi1n0j30q104tdh7.jpg)

#### 单一职责原则

> 一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。不过在现实开发中，这个原则是最不可能遵守的，因为每个人对一个类的哪些功能算是同一类型的职责判断都不相同。

#### 开放封闭原则

> 软件实体应该是可扩展，而不可修改的。也就是说，你写完一个类，要想添加功能，不能修改原有类，而是想办法扩展该类。有多种设计模式可以达到这一要求。

#### 里式替换原则

> 当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。也就是说接口或父类出现的地方，实现接口的类或子类可以代入，这主要依赖于多态和继承。

#### 接口分离原则

> 不能强迫用户去依赖那些他们不使用的接口。换句话说，使用多个专门的接口比使用单一的总接口总要好。 不要提供一个大的接口包括所有功能，应该根据功能把这些接口分割，减少依赖。

#### 依赖倒置原则

> 1. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
> 2. 抽象不应该依赖于细节，细节应该依赖于抽象



------



## 设计模式类别

### 一、简单工厂

> 简单工厂是由一个抽象产品类和一个具体工厂类实现的
>

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8wenh6regj310u0l2410.jpg)

面向对象的编程，并不是类越多越好，类的划分是为了封装，单分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。

#### 简单工厂的优缺点

- **优点**在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

- **缺点**在于增加功能时，我们是一定需要给运算工厂类的方法里面增加Case的分支条件，修改原有的类，相当于对扩展开放，也对修改开放，违背开放封闭原则。



### 二、策略模式

> 它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8yllb5zlwj30xm0mudib.jpg)

#### 优点

- 算法可以自由切换
- 避免使用多重条件判断，将决策权转接给高层，传入策略执行即可
- 扩展性良好

#### 缺点

- 策略类会暴露在外，客户必须知道具体策略（解决方案：结合简单工厂方法、代理模式、享元模式）

#### 使用场景

- 多个类只有在算法上稍有不同
- 算法需要自由切换
- 需要屏蔽算法规则

#### 注意事项：

- 一个策略家族的具体策略数量不得超过4个，否则使用混合模式解决策略类膨胀和对外暴露问题



### 三、装饰模式（Decorator）

> 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8z1njweyvj31ag0pa0x1.jpg)

#### 要点

- 通过组合而非继承的手法，Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能，避免了由于继承的不良使用而带来的灵活性差和多子类的膨胀

- Decorator类在接口上表现为is-a Component的**继承**关系(为了完善接口的规范)，在实现上表现为has-a Component的**组合**关系(为了将来支持调用ConcreteCompoent)

#### 适用场景

以下图举例子：来说明装饰模式的使用场景，如果采取左边的继承方式，则导致类的数目爆炸增长

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8yu34mcp1j31dv0giafi.jpg)

#### 优点

- 可以不用修改原有的接口，就可以实现新功能的添加
- 装饰者可以方便的转换原有接口中的实现

#### 缺点

- 复杂性增加，装饰者模式会导致许多小类的产生。



### 四、代理模式

> 为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8z37eukr6j30uk0osgo9.jpg)

#### 场景

- 在面向对象系统中，有些对象由于某种原因（比如对象创建的开销很大，或者某些操作需要安全控制，或者需要进程外的访问等），直接访问会给使用者或者系统结构带来很多麻烦。

#### 要点

- Proxy并不一定要求保持接口完整的一致性，只要能够实现间接控制，有时候损及一些透明性是可以接受的



### 五、工厂方法模式

> 定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8zq9v7iv1j31560qmn9e.jpg)

#### 简单工厂模式的优缺点

- **优点**在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

- **缺点**在于增加功能时，我们是一定需要给运算工厂类的方法里面增加Case的分支条件，修改原有的类，相当于对扩展开放，也对修改开放，违背开放封闭原则。

#### 工厂方法模式相比于简单工厂模式

- 工厂方法克服了额简单工厂违背开发封闭原则的缺点，又保持了封装对象创建过程的优点

#### 工厂模式和简单工厂模式的对比图（以计算器为例子）

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8zqpn3qr8j31du0mcqhq.jpg)

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g8zqpkwrbpj312y0iotm6.jpg)



### 六、原型模式

> 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g9134ss8gsj312g0jqq57.jpg)

#### 区别

工厂模式，建造者模式，原型模式都是通过已有类对象来构造新对象，区别在于

- 工厂模式：侧重批量生产多个相互依赖类的对象

- 建造者模式：侧重复杂对象的分步骤创建

- 原型模式：通过复制自身来实现新对象构造（**性能优良，避免了构造函数的约束**）

#### 使用场景

- 资源优化场景，类的初始化需要资源（数据，硬件）比较大
- 性能和要求安全，通过new频繁生产时会有数据准备和权限问题
- 一个对象多个修改场景，eg学生表格

#### 注意事项

- 构造函数将不被执行
- 深浅拷贝问题，当类内部含有指针时，需要自己实现深拷贝。



### 七、模板方法

> 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g913i0ep0ej30v40fetap.jpg)

#### 特点

- 模板方法提供了一个代码复用平台

- 把不变的行为搬移到超类，取出子类中重复的代码



### 八、外观模式

> 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g915eu8hx5j30qr0gogrp.jpg)

#### 优点

- 减少了系统的相互依赖
- 提高了灵活性。不管系统内部如何变化，只要不影响到外观对象，任你自由活动
- 提高了安全性。想让你访问子系统的哪些业务就开通哪些逻辑，不在外观上开通的方法，你就访问不到

#### 缺点

不符合开闭原则，修改麻烦

- 不符合开不原则，修改很麻烦

#### 使用场景

- 为一个复杂的模块或子系统提供一个外界访问的接口
- 子系统相对独立，外界对子系统的访问只要黑箱操作即可
- 预防低水平人员带来的风险扩散

### 九、建造者模式

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g918n5yfp5j30ym0hoq55.jpg)

#### 作用

- 在用户不知道对象的创建过程和细节的情况下就可以直接创建复杂的对象
- 方便用户创建复杂的对象（不需要知道实现过程）

#### 适用场景

- 差异性不大（具备共性）但产品内部细节复杂的产品

#### 建造者模式与抽象工厂模式的比较

- 建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车
- 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象；而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。



### 十、观察者模式（发布订阅模式）

> 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g937h86q2jj30y40miwhp.jpg)

观察者模式趋势就是在解除耦合，让耦合的双方都依赖与抽象，而不是依赖于具体

#### 适用场景

- 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
- 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

#### 不足

- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。
- 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。
- 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。



### 十一、抽象工厂模式

> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g93e5elophj31260qegon.jpg)

在我的代码中的抽象工厂样例的类图：

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g93e5zjle8j31000mi11t.jpg)

#### 抽象工厂和工厂方法的区别

最大的区别就是抽象工厂模式不止一个产品簇，并且每个工厂都不止生产一种产品。比如在工厂方法模式中，不同的工厂可以生产不同的产品。比如键盘、鼠标。分别由键盘工厂和鼠标工厂，但是智能生产一种键盘和鼠标。但是在抽象工厂模式中，每个工厂可以生产键盘和鼠标。还可以生产不同牌子的键盘和鼠标。说到这里，其实抽象工厂模式可以和简单工厂模式结合起来，来创建不同的工厂。

#### 优点

- 易于交换产品系列，只要改变创建的工厂对象就可以实现产品系列的更换。
- 它让具体的创建实例的过程于客户端分离，客户端是通过它们抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。

#### 缺点

- 添加产品则非常麻烦需要修改很多类。

##### 解决方案

《大话设计模式》  采用简单工厂改进抽象工厂，并用反射+配置文件解决其缺点。



### 十二、状态模式

> 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95id2jl53j318a0q27ek.jpg)

#### 目的

- 为了消除庞大的条件分支语句，状态模式通过各种状态转移逻辑分布到State的子类之间，来减少相互的依赖

#### 适用场景

- 当一个行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式



### 十三、适配器模式

> 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95im7294hj313k0i8jza.jpg)

#### 适用范围

- 系统的行为和数据都正确，但接口不符时，使用适配器模式使控制范围之外的一个原有对象与某个接口匹配。
- 复用一些现存的类，但是接口又与复用环境要求不一致的情况

#### 分类

- 类适配器模式（通过多重继承对一个接口与另一个接口进行匹配）
- 对象适配器模式（这里主要用这个模式）



### 十四、备忘录模式

> 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95jmq4u2ej31ga0oek5n.jpg)

#### 使用场景

当对象状态改变时，有可能这个状态无效，这时就可以通过备忘录将其复原

#### 缺点

当对象状态需要完整存储到备忘录对象中，如果状态数据很大很多，备忘录对象会非常消耗内存





### 十五、组合模式

> 将对象组合成树形结构以表示"部分=整体"的层次结构。组合模式使得用户对单个对象的组合对象的使用具有一致性。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95s43mumqj310m0oawrf.jpg)

#### 适用范围

- 需求中是体现部分与整体层次的结构时，希望用户忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象时，就应该考虑适用组合模式。
- 整体与部分可以被一致对待

#### 透明方式与安全方式

透明方式：Leaf也可以调用Add和Remove，是的叶结点和枝结点对于外界没有区别

安全方式：在Component接口中不去声明Add和Remove方法，而是在Composite中声明用来管理子类的对象（由于不够透明，所以树叶和树枝类将不具有相同的接口，**客户端的调用需要做相应的判断**，带来了不便）



### 十六、迭代器模式

> 提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95uyhxf36j314m0q04a2.jpg)

#### 注意

- 现在各个语言中都已经有封装好的迭代器接口，所以其本身的学习价值大于实用价值



### 十七、单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95vykgscij31c60ain62.jpg)



### 十八、桥接模式

> 将抽象部分与它的实现部分分离，使它们都可以独立地变化。
>
> **通俗解释**：实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。

![](https://tva1.sinaimg.cn/large/006y8mN6gy1g95wp1u93tj31em0qc4ck.jpg)



### 十九、命令模式

> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。















